<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Animal Kingdom</title>
		<link rel="stylesheet" href="styles.css" />
		<script src="https://unpkg.com/lucide@latest"></script>
	</head>
	<body>
		<button id="theme-toggle-btn" class="theme-toggle" title="Toggle theme"><i data-lucide="moon"></i></button>
		<button id="mute-toggle-btn" class="mute-toggle" title="Toggle sound (M)"><i data-lucide="volume-2"></i></button>

		<header>
			<img src="logo.png" alt="Animal Kingdom Logo" class="logo" />
		</header>

		<main>
			<div id="setup-screen">
				<h2>Game Setup</h2>

				<div class="mode-selection">
					<button id="standard-mode-btn" class="mode-btn active">
						<i data-lucide="users"></i><span>Standard Battle</span>
					</button>
					<button id="challenger-mode-btn" class="mode-btn">
						<i data-lucide="trophy"></i><span>New Challenger</span>
					</button>
				</div>

				<div class="animal-abilities-section collapsed">
					<div class="abilities-header">
						<h3>Animal Abilities</h3>
						<button id="toggle-abilities-btn" class="toggle-abilities-btn">
							<i data-lucide="chevron-down"></i><span>Show Abilities</span>
						</button>
					</div>
					<div class="abilities-list hidden"></div>
				</div>

				<div id="standard-setup">
					<div class="setup-section">
						<label for="player-count">Number of Players:</label>
						<select id="player-count">
							<option value="2">2</option>
							<option value="3">3</option>
							<option value="4">4</option>
							<option value="5">5</option>
							<option value="6">6</option>
							<option value="7">7</option>
							<option value="8">8</option>
							<option value="9">9</option>
							<option value="10">10</option>
						</select>
					</div>
					<div id="player-selections" class="setup-section"></div>
				</div>

				<div id="challenger-setup" class="setup-section" style="display: none;">
					<div class="challenger-selection">
						<h3>Choose Your Fighter</h3>
						<div id="unlocked-animals-grid"></div>
					</div>
					<div class="challenger-opponent">
						<h3>Your Opponent</h3>
						<div id="challenger-opponent-display"></div>
					</div>
				</div>
				<button id="start-game-btn"><i data-lucide="play"></i>Start Game</button>
			</div>

			<div id="game-screen">
				<div id="players-container"></div>
				<div id="game-interface">
					<div id="controls-container">
						<div id="turn-indicator">Player 1's Turn</div>
						<div class="action-buttons">
							<button class="action-btn" data-action="attack">
								<i data-lucide="crosshair"></i><span><u>A</u>ttack</span>
							</button>
							<button class="action-btn" data-action="ability">
								<i data-lucide="sparkles"></i><span>Use A<u>b</u>ility</span>
							</button>
							<button class="action-btn" data-action="heal">
								<i data-lucide="heart"></i><span><u>H</u>eal (1 left)</span>
							</button>
							<button class="action-btn" data-action="shield">
								<i data-lucide="shield-check"></i><span><u>S</u>hield (1 left)</span>
							</button>
							<button class="action-btn" data-action="nothing">
								<i data-lucide="pause"></i><span>Do <u>N</u>othing</span>
							</button>
						</div>
						<button id="undo-btn" class="undo-btn" title="Undo last turn (U)">
							<i data-lucide="undo"></i><span><u>U</u>ndo</span>
						</button>
					</div>
					<div id="log-container">
						<h3>Game Log</h3>
						<div id="game-log"></div>
						<div class="log-buttons">
							<button id="copy-log-btn"><i data-lucide="clipboard-copy"></i>Copy to Clipboard</button>
							<button id="save-log-btn"><i data-lucide="download"></i>Save Log</button>
						</div>
					</div>
				</div>
			</div>

			<div id="game-over-screen">
				<div class="game-over-modal">
					<h2 id="winner-announcement"></h2>
					<div class="button-group">
						<button id="play-again-btn" class="primary"><i data-lucide="refresh-cw"></i>Play Again</button>
						<button id="view-log-btn"><i data-lucide="eye"></i>View Log</button>
						<button id="copy-log-game-over-btn">
							<i data-lucide="clipboard-copy"></i>Copy to Clipboard
						</button>
						<button id="save-log-game-over-btn"><i data-lucide="download"></i>Save Log</button>
					</div>
				</div>
			</div>

			<div id="fullscreen-log-modal">
				<div class="fullscreen-log-container">
					<div class="fullscreen-log-header">
						<h2>Game Log</h2>
						<button id="close-fullscreen-log-btn"><i data-lucide="x"></i>Close</button>
					</div>
					<div id="fullscreen-log-content"></div>
					<div class="fullscreen-log-actions">
						<button id="copy-log-fullscreen-btn">
							<i data-lucide="clipboard-copy"></i>Copy to Clipboard
						</button>
						<button id="save-log-fullscreen-btn"><i data-lucide="download"></i>Save Log</button>
					</div>
				</div>
			</div>

			<div id="keyboard-shortcuts-modal">
				<div class="shortcuts-modal">
					<h2>Keyboard Shortcuts</h2>
					<table>
						<tr>
							<td>A</td>
							<td>Attack</td>
						</tr>
						<tr>
							<td>B</td>
							<td>Use Ability</td>
						</tr>
						<tr>
							<td>H</td>
							<td>Heal</td>
						</tr>
						<tr>
							<td>S</td>
							<td>Shield</td>
						</tr>
						<tr>
							<td>N</td>
							<td>Do Nothing</td>
						</tr>
						<tr>
							<td>U</td>
							<td>Undo</td>
						</tr>
						<tr>
							<td>M</td>
							<td>Toggle Mute</td>
						</tr>
						<tr>
							<td>?</td>
							<td>Show this help</td>
						</tr>
						<tr>
							<td>Esc</td>
							<td>Close this help</td>
						</tr>
					</table>
					<button id="close-shortcuts-btn"><i data-lucide="x"></i>Close</button>
				</div>
			</div>
		</main>

		<script>
			document.addEventListener('DOMContentLoaded', () => {
				// --- DOM ELEMENTS ---
				const setupScreen = document.getElementById('setup-screen');
				const gameScreen = document.getElementById('game-screen');
				const playerCountSelect = document.getElementById('player-count');
				const playerSelectionsContainer = document.getElementById('player-selections');
				const startGameBtn = document.getElementById('start-game-btn');
				const playersContainer = document.getElementById('players-container');
				const turnIndicator = document.getElementById('turn-indicator');
				const actionButtonsContainer = document.querySelector('.action-buttons');
				const gameLog = document.getElementById('game-log');
				const gameOverScreen = document.getElementById('game-over-screen');
				const winnerAnnouncement = document.getElementById('winner-announcement');
				const playAgainBtn = document.getElementById('play-again-btn');
				const saveLogBtn = document.getElementById('save-log-btn');
				const saveLogGameOverBtn = document.getElementById('save-log-game-over-btn');
				const copyLogBtn = document.getElementById('copy-log-btn');
				const copyLogGameOverBtn = document.getElementById('copy-log-game-over-btn');
				const keyboardShortcutsModal = document.getElementById('keyboard-shortcuts-modal');
				const closeShortcutsBtn = document.getElementById('close-shortcuts-btn');
				const themeToggleBtn = document.getElementById('theme-toggle-btn');
				const viewLogBtn = document.getElementById('view-log-btn');
				const fullscreenLogModal = document.getElementById('fullscreen-log-modal');
				const closeFullscreenLogBtn = document.getElementById('close-fullscreen-log-btn');
				const fullscreenLogContent = document.getElementById('fullscreen-log-content');
				const copyLogFullscreenBtn = document.getElementById('copy-log-fullscreen-btn');
				const saveLogFullscreenBtn = document.getElementById('save-log-fullscreen-btn');
				const toggleAbilitiesBtn = document.getElementById('toggle-abilities-btn');
				const abilitiesList = document.querySelector('.abilities-list');
				const undoBtn = document.getElementById('undo-btn');
				const muteToggleBtn = document.getElementById('mute-toggle-btn');
				const standardModeBtn = document.getElementById('standard-mode-btn');
				const challengerModeBtn = document.getElementById('challenger-mode-btn');
				const standardSetup = document.getElementById('standard-setup');
				const challengerSetup = document.getElementById('challenger-setup');
				const unlockedAnimalsGrid = document.getElementById('unlocked-animals-grid');
				const challengerOpponentDisplay = document.getElementById('challenger-opponent-display');

				// --- SOUND SYSTEM ---
				const audioContext = new (window.AudioContext || window.webkitAudioContext)();
				let isMuted = false;

				function playSound(type, options = {}) {
					if (isMuted) return;
					const now = audioContext.currentTime;
					const oscillator = audioContext.createOscillator();
					const gainNode = audioContext.createGain();

					oscillator.connect(gainNode);
					gainNode.connect(audioContext.destination);

					switch (type) {
						case 'attack':
							oscillator.type = 'sawtooth';
							oscillator.frequency.setValueAtTime(200, now);
							oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.1);
							gainNode.gain.setValueAtTime(0.3, now);
							gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
							oscillator.start(now);
							oscillator.stop(now + 0.1);
							break;

						case 'damage':
							oscillator.type = 'sine';
							oscillator.frequency.setValueAtTime(440, now);
							oscillator.frequency.exponentialRampToValueAtTime(220, now + 0.15);
							gainNode.gain.setValueAtTime(0.2, now);
							gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
							oscillator.start(now);
							oscillator.stop(now + 0.15);
							break;

						case 'heal':
							const healOsc1 = audioContext.createOscillator();
							const healOsc2 = audioContext.createOscillator();
							const healGain = audioContext.createGain();

							healOsc1.connect(healGain);
							healOsc2.connect(healGain);
							healGain.connect(audioContext.destination);

							healOsc1.type = 'sine';
							healOsc2.type = 'sine';
							healOsc1.frequency.setValueAtTime(523.25, now);
							healOsc2.frequency.setValueAtTime(659.25, now);
							healGain.gain.setValueAtTime(0.15, now);
							healGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

							healOsc1.start(now);
							healOsc2.start(now);
							healOsc1.stop(now + 0.3);
							healOsc2.stop(now + 0.3);
							return;

						case 'shield':
							oscillator.type = 'triangle';
							oscillator.frequency.setValueAtTime(300, now);
							oscillator.frequency.linearRampToValueAtTime(400, now + 0.05);
							oscillator.frequency.linearRampToValueAtTime(300, now + 0.1);
							gainNode.gain.setValueAtTime(0.2, now);
							gainNode.gain.linearRampToValueAtTime(0.15, now + 0.05);
							gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
							oscillator.start(now);
							oscillator.stop(now + 0.2);
							break;

						case 'howl':
							oscillator.type = 'sine';
							oscillator.frequency.setValueAtTime(200, now);
							oscillator.frequency.linearRampToValueAtTime(400, now + 0.3);
							oscillator.frequency.linearRampToValueAtTime(300, now + 0.6);
							gainNode.gain.setValueAtTime(0.2, now);
							gainNode.gain.linearRampToValueAtTime(0.25, now + 0.3);
							gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
							oscillator.start(now);
							oscillator.stop(now + 0.6);
							break;

						case 'spitball':
							oscillator.type = 'square';
							oscillator.frequency.setValueAtTime(150, now);
							oscillator.frequency.exponentialRampToValueAtTime(300, now + 0.08);
							gainNode.gain.setValueAtTime(0.15, now);
							gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
							oscillator.start(now);
							oscillator.stop(now + 0.08);
							break;

						case 'strike':
							oscillator.type = 'sawtooth';
							oscillator.frequency.setValueAtTime(250, now);
							oscillator.frequency.exponentialRampToValueAtTime(150, now + 0.12);
							gainNode.gain.setValueAtTime(0.25, now);
							gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
							oscillator.start(now);
							oscillator.stop(now + 0.12);

							setTimeout(() => {
								const osc2 = audioContext.createOscillator();
								const gain2 = audioContext.createGain();
								osc2.connect(gain2);
								gain2.connect(audioContext.destination);
								osc2.type = 'sawtooth';
								const now2 = audioContext.currentTime;
								osc2.frequency.setValueAtTime(250, now2);
								osc2.frequency.exponentialRampToValueAtTime(150, now2 + 0.12);
								gain2.gain.setValueAtTime(0.25, now2);
								gain2.gain.exponentialRampToValueAtTime(0.01, now2 + 0.12);
								osc2.start(now2);
								osc2.stop(now2 + 0.12);
							}, 100);
							return;

						case 'rampage':
							for (let i = 0; i < 4; i++) {
								setTimeout(() => {
									const rampOsc = audioContext.createOscillator();
									const rampGain = audioContext.createGain();
									rampOsc.connect(rampGain);
									rampGain.connect(audioContext.destination);
									rampOsc.type = 'sawtooth';
									const rampNow = audioContext.currentTime;
									rampOsc.frequency.setValueAtTime(300 - i * 30, rampNow);
									rampOsc.frequency.exponentialRampToValueAtTime(150 - i * 20, rampNow + 0.08);
									rampGain.gain.setValueAtTime(0.3, rampNow);
									rampGain.gain.exponentialRampToValueAtTime(0.01, rampNow + 0.08);
									rampOsc.start(rampNow);
									rampOsc.stop(rampNow + 0.08);
								}, i * 60);
							}
							return;

						case 'mischief':
							oscillator.type = 'triangle';
							oscillator.frequency.setValueAtTime(800, now);
							oscillator.frequency.exponentialRampToValueAtTime(200, now + 0.25);
							gainNode.gain.setValueAtTime(0.2, now);
							gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
							oscillator.start(now);
							oscillator.stop(now + 0.25);
							break;

						case 'defeat':
							oscillator.type = 'sine';
							oscillator.frequency.setValueAtTime(300, now);
							oscillator.frequency.exponentialRampToValueAtTime(150, now + 0.4);
							gainNode.gain.setValueAtTime(0.2, now);
							gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
							oscillator.start(now);
							oscillator.stop(now + 0.4);
							break;

						case 'victory':
							const notes = [523.25, 659.25, 783.99, 1046.5];
							notes.forEach((freq, index) => {
								setTimeout(() => {
									const victoryOsc = audioContext.createOscillator();
									const victoryGain = audioContext.createGain();
									victoryOsc.connect(victoryGain);
									victoryGain.connect(audioContext.destination);
									victoryOsc.type = 'sine';
									const victoryNow = audioContext.currentTime;
									victoryOsc.frequency.setValueAtTime(freq, victoryNow);
									victoryGain.gain.setValueAtTime(0.2, victoryNow);
									victoryGain.gain.exponentialRampToValueAtTime(0.01, victoryNow + 0.3);
									victoryOsc.start(victoryNow);
									victoryOsc.stop(victoryNow + 0.3);
								}, index * 150);
							});
							return;

						case 'nothing':
							oscillator.type = 'sine';
							oscillator.frequency.setValueAtTime(200, now);
							gainNode.gain.setValueAtTime(0.1, now);
							gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
							oscillator.start(now);
							oscillator.stop(now + 0.1);
							break;

						case 'sleep':
							oscillator.type = 'sine';
							oscillator.frequency.setValueAtTime(400, now);
							oscillator.frequency.linearRampToValueAtTime(300, now + 0.2);
							gainNode.gain.setValueAtTime(0.15, now);
							gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
							oscillator.start(now);
							oscillator.stop(now + 0.2);
							break;
					}
				}

				// --- GAME STATE ---
				let state = {};
				let stateHistory = [];
				let unlockedAnimals = new Set();
				let currentMode = 'standard';
				let selectedChallengerAnimal = null;
				let selectedOpponentAnimal = null;

				const ANIMAL_ROSTER = {
					Coyote: {
						name: 'Coyote',
						abilityDesc: 'Howl: Puts all other animals to sleep for one turn. Cooldown: 2 turns.',
					},
					Llama: {name: 'Llama', abilityDesc: 'Spitball: An attack with random damage (0-2).'},
					Tiger: {name: 'Tiger', abilityDesc: 'Strike: Hits two different opponents for 1 damage each.'},
					Gorilla: {name: 'Gorilla', abilityDesc: 'Rampage: A one-time attack that deals 4x damage.'},
					Monkey: {
						name: 'Monkey',
						abilityDesc: "Mischief: A one-time ability that disables another player's ability permanently.",
					},
				};
				const INITIAL_HP = 3;

				// --- SETUP LOGIC ---
				function initializeSetup() {
					loadUnlockedAnimals();
					loadTheme();
					loadMutePreference();
					updateAbilitiesList();
					updatePlayerSelections();
					updateChallengerMode();
					playerCountSelect.addEventListener('change', updatePlayerSelections);
					startGameBtn.addEventListener('click', startGame);
					playAgainBtn.addEventListener('click', () => location.reload());
					saveLogBtn.addEventListener('click', saveGameLog);
					saveLogGameOverBtn.addEventListener('click', saveGameLog);
					copyLogBtn.addEventListener('click', copyGameLog);
					copyLogGameOverBtn.addEventListener('click', copyGameLog);
					closeShortcutsBtn.addEventListener('click', hideKeyboardShortcuts);
					themeToggleBtn.addEventListener('click', toggleTheme);
					muteToggleBtn.addEventListener('click', toggleMute);
					viewLogBtn.addEventListener('click', showFullscreenLog);
					closeFullscreenLogBtn.addEventListener('click', hideFullscreenLog);
					copyLogFullscreenBtn.addEventListener('click', copyGameLog);
					saveLogFullscreenBtn.addEventListener('click', saveGameLog);
					toggleAbilitiesBtn.addEventListener('click', toggleAbilities);
					undoBtn.addEventListener('click', handleUndo);
					standardModeBtn.addEventListener('click', () => switchMode('standard'));
					challengerModeBtn.addEventListener('click', () => switchMode('challenger'));
					document.addEventListener('keydown', handleKeyPress);
				}

				function loadUnlockedAnimals() {
					const saved = localStorage.getItem('animalKingdomUnlockedAnimals');
					if (saved) {
						unlockedAnimals = new Set(JSON.parse(saved));
					} else {
						unlockedAnimals = new Set(['Coyote']);
					}
				}

				function saveUnlockedAnimals() {
					localStorage.setItem('animalKingdomUnlockedAnimals', JSON.stringify([...unlockedAnimals]));
				}

				function unlockAnimal(animalName) {
					if (!unlockedAnimals.has(animalName)) {
						unlockedAnimals.add(animalName);
						saveUnlockedAnimals();
					}
				}

				function loadTheme() {
					const savedTheme = localStorage.getItem('animalKingdomTheme');
					if (savedTheme === 'dark') {
						document.body.classList.add('dark-mode');
						themeToggleBtn.innerHTML = '<i data-lucide="sun"></i>';
					} else {
						themeToggleBtn.innerHTML = '<i data-lucide="moon"></i>';
					}
					lucide.createIcons();
				}

				function toggleTheme() {
					document.body.classList.toggle('dark-mode');
					const isDark = document.body.classList.contains('dark-mode');
					localStorage.setItem('animalKingdomTheme', isDark ? 'dark' : 'light');
					themeToggleBtn.innerHTML = isDark ? '<i data-lucide="sun"></i>' : '<i data-lucide="moon"></i>';
					lucide.createIcons();
				}

				function loadMutePreference() {
					const savedMute = localStorage.getItem('animalKingdomMuted');
					if (savedMute === 'true') {
						isMuted = true;
						muteToggleBtn.innerHTML = '<i data-lucide="volume-x"></i>';
					} else {
						isMuted = false;
						muteToggleBtn.innerHTML = '<i data-lucide="volume-2"></i>';
					}
					lucide.createIcons();
				}

				function toggleMute() {
					isMuted = !isMuted;
					localStorage.setItem('animalKingdomMuted', isMuted.toString());
					muteToggleBtn.innerHTML = isMuted ? '<i data-lucide="volume-x"></i>' : '<i data-lucide="volume-2"></i>';
					lucide.createIcons();
				}

				function updateAbilitiesList() {
					const animalEmojis = {
						Coyote: '🐺',
						Llama: '🦙',
						Tiger: '🐯',
						Gorilla: '🦍',
						Monkey: '🐒',
					};

					const abilitiesHTML = Object.keys(ANIMAL_ROSTER)
						.filter((animal) => unlockedAnimals.has(animal))
						.map((animal) => {
							const emoji = animalEmojis[animal];
							const desc = ANIMAL_ROSTER[animal].abilityDesc;
							return `<div class="ability-item">
								<strong>${emoji} ${animal}</strong>
								<p>${desc}</p>
							</div>`;
						})
						.join('');

					abilitiesList.innerHTML = abilitiesHTML;
				}

				function toggleAbilities() {
					const section = document.querySelector('.animal-abilities-section');
					const isHidden = abilitiesList.classList.toggle('hidden');
					if (isHidden) {
						section.classList.add('collapsed');
						toggleAbilitiesBtn.innerHTML = '<i data-lucide="chevron-down"></i><span>Show Abilities</span>';
					} else {
						section.classList.remove('collapsed');
						toggleAbilitiesBtn.innerHTML = '<i data-lucide="chevron-up"></i><span>Hide Abilities</span>';
					}
					lucide.createIcons();
				}

				function showKeyboardShortcuts() {
					keyboardShortcutsModal.style.display = 'flex';
				}

				function hideKeyboardShortcuts() {
					keyboardShortcutsModal.style.display = 'none';
				}

				function showFullscreenLog() {
					const logHTML = state.log
						.map((entry, index) => {
							let prefix = '';
							if (entry.indent > 0) {
								const nextEntry = state.log[index + 1];
								const hasNextSibling = nextEntry && nextEntry.indent === entry.indent;
								const hasChildren = nextEntry && nextEntry.indent > entry.indent;

								if (entry.indent === 1) {
									if (hasChildren) {
										prefix = hasNextSibling ? '├─┐ ' : '└─┐ ';
									} else {
										prefix = hasNextSibling ? '├── ' : '└── ';
									}
								} else if (entry.indent === 2) {
									const connector = hasNextSibling ? '├─┐ ' : '└─┐ ';
									if (hasChildren) {
										prefix = '  ' + connector;
									} else {
										prefix = '  ' + (hasNextSibling ? '├── ' : '└── ');
									}
								} else if (entry.indent === 3) {
									const connector = hasNextSibling ? '├── ' : '└── ';
									prefix = '    ' + connector;
								}
							}
							return `<div class="log-entry">${prefix}${entry.message}</div>`;
						})
						.join('');
					fullscreenLogContent.innerHTML = logHTML;
					fullscreenLogModal.style.display = 'flex';
				}

				function hideFullscreenLog() {
					fullscreenLogModal.style.display = 'none';
				}

				function handleKeyPress(event) {
					const key = event.key.toLowerCase();

					if (key === 'm') {
						toggleMute();
						event.preventDefault();
						return;
					}

					const currentPlayer = state.players[state.currentPlayerIndex];

					if (
						state.gameState !== 'playing'
						|| state.actionInProgress
						|| state.turnSkipped
						|| (currentPlayer && currentPlayer.isComputer)
					) {
						if (event.key === '?' || event.key === '/') {
							showKeyboardShortcuts();
							event.preventDefault();
						} else if (event.key === 'Escape') {
							hideKeyboardShortcuts();
							event.preventDefault();
						} else if (
							state.gameState === 'playing'
							&& ((event.key.toLowerCase() === 'z' && (event.ctrlKey || event.metaKey))
							|| event.key.toLowerCase() === 'u')
						) {
							if (!undoBtn.disabled) {
								handleUndo();
							}
							event.preventDefault();
						}
						return;
					}

					if (key === '?') {
						showKeyboardShortcuts();
						event.preventDefault();
					} else if (key === 'escape') {
						hideKeyboardShortcuts();
						event.preventDefault();
					} else if ((key === 'z' && (event.ctrlKey || event.metaKey)) || key === 'u') {
						if (!undoBtn.disabled) {
							handleUndo();
						}
						event.preventDefault();
					} else if (key === 'a') {
						document.querySelector('[data-action="attack"]').click();
						event.preventDefault();
					} else if (key === 'b') {
						const abilityBtn = document.querySelector('[data-action="ability"]');
						if (!abilityBtn.disabled) {
							abilityBtn.click();
						}
						event.preventDefault();
					} else if (key === 'h') {
						const healBtn = document.querySelector('[data-action="heal"]');
						if (!healBtn.disabled) {
							healBtn.click();
						}
						event.preventDefault();
					} else if (key === 's') {
						const shieldBtn = document.querySelector('[data-action="shield"]');
						if (!shieldBtn.disabled) {
							shieldBtn.click();
						}
						event.preventDefault();
					} else if (key === 'n') {
						document.querySelector('[data-action="nothing"]').click();
						event.preventDefault();
					}
				}

				function getLogText() {
					return state.log
						.map((entry, index) => {
							if (entry.indent === 0) {
								return entry.message;
							}

							const nextEntry = state.log[index + 1];
							const hasNextSibling = nextEntry && nextEntry.indent === entry.indent;
							const hasChildren = nextEntry && nextEntry.indent > entry.indent;

							let prefix = '';
							if (entry.indent === 1) {
								if (hasChildren) {
									prefix = hasNextSibling ? '├─┐ ' : '└─┐ ';
								} else {
									prefix = hasNextSibling ? '├── ' : '└── ';
								}
							} else if (entry.indent === 2) {
								const connector = hasNextSibling ? '├─┐ ' : '└─┐ ';
								if (hasChildren) {
									prefix = '  ' + connector;
								} else {
									prefix = '  ' + (hasNextSibling ? '├── ' : '└── ');
								}
							} else if (entry.indent === 3) {
								const connector = hasNextSibling ? '├── ' : '└── ';
								prefix = '    ' + connector;
							}

							return prefix + entry.message;
						})
						.join('\n');
				}

				function saveGameLog() {
					const logText = getLogText();
					const blob = new Blob([logText], {type: 'text/plain'});
					const url = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					a.download = `animal-kingdom-log-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
					document.body.appendChild(a);
					a.click();
					document.body.removeChild(a);
					URL.revokeObjectURL(url);
				}

				function copyGameLog() {
					const logText = getLogText();
					navigator.clipboard
						.writeText(logText)
						.then(() => {
							const buttonClicked = event.target;
							const originalText = buttonClicked.textContent;
							buttonClicked.textContent = 'Copied!';
							buttonClicked.style.backgroundColor = 'var(--hp-full)';
							setTimeout(() => {
								buttonClicked.textContent = originalText;
								buttonClicked.style.backgroundColor = '';
							}, 2000);
						})
						.catch((error) => {
							console.error('Failed to copy log:', error);
							const buttonClicked = event.target;
							const originalText = buttonClicked.textContent;
							buttonClicked.textContent = 'Copy failed';
							buttonClicked.style.backgroundColor = 'var(--hp-low)';
							setTimeout(() => {
								buttonClicked.textContent = originalText;
								buttonClicked.style.backgroundColor = '';
							}, 2000);
						});
				}

				function switchMode(mode) {
					currentMode = mode;
					if (mode === 'standard') {
						standardModeBtn.classList.add('active');
						challengerModeBtn.classList.remove('active');
						standardSetup.style.display = 'block';
						challengerSetup.style.display = 'none';
						startGameBtn.textContent = 'Start Game';
						lucide.createIcons();
					} else {
						standardModeBtn.classList.remove('active');
						challengerModeBtn.classList.add('active');
						standardSetup.style.display = 'none';
						challengerSetup.style.display = 'block';
						startGameBtn.innerHTML = '<i data-lucide="play"></i><span>Fight Challenger</span>';
						lucide.createIcons();
						updateChallengerMode();
					}
					updateStartButtonState();
				}

				function updateChallengerMode() {
					if (currentMode !== 'challenger') return;

					const lockedAnimals = Object.keys(ANIMAL_ROSTER).filter(animal => !unlockedAnimals.has(animal));

					unlockedAnimalsGrid.innerHTML = '';
					[...unlockedAnimals].forEach(animal => {
						const card = document.createElement('div');
						card.classList.add('animal-choice-card');
						if (selectedChallengerAnimal === animal) {
							card.classList.add('selected');
						}
						card.innerHTML = `
							<div class="animal-choice-name">${animal}</div>
							<div class="animal-choice-desc">${ANIMAL_ROSTER[animal].abilityDesc}</div>
						`;
						card.addEventListener('click', () => {
							selectedChallengerAnimal = animal;
							updateChallengerMode();
							updateStartButtonState();
						});
						unlockedAnimalsGrid.appendChild(card);
					});

					if (lockedAnimals.length > 0) {
						if (!selectedOpponentAnimal || unlockedAnimals.has(selectedOpponentAnimal)) {
							selectedOpponentAnimal = lockedAnimals[Math.floor(Math.random() * lockedAnimals.length)];
						}
						challengerOpponentDisplay.innerHTML = `
							<div class="challenger-opponent-card">
								<div class="opponent-name">${selectedOpponentAnimal}</div>
								<div class="opponent-label">Computer Opponent</div>
							</div>
						`;
					} else {
						challengerOpponentDisplay.innerHTML = `
							<div class="no-challengers">
								<p>All animals unlocked!</p>
								<p>Play standard mode to test your skills.</p>
							</div>
						`;
					}
				}

				function updateStartButtonState() {
					if (currentMode === 'challenger') {
						const lockedAnimals = Object.keys(ANIMAL_ROSTER).filter(animal => !unlockedAnimals.has(animal));
						startGameBtn.disabled = !selectedChallengerAnimal || lockedAnimals.length === 0;
					} else {
						startGameBtn.disabled = false;
					}
				}

				function updatePlayerSelections() {
					const count = parseInt(playerCountSelect.value, 10);
					const existingData = [];
					playerSelectionsContainer.querySelectorAll('.player-setup').forEach((setupDiv) => {
						const nameInput = setupDiv.querySelector('input[type="text"]');
						const animalSelect = setupDiv.querySelector('select');
						const playerTypeSelect = setupDiv.querySelector('.player-type-select');
						existingData.push({
							name: nameInput ? nameInput.value : '',
							animal: animalSelect ? animalSelect.value : '',
							playerType: playerTypeSelect ? playerTypeSelect.value : 'human',
						});
					});

					playerSelectionsContainer.innerHTML = '';
					for (let i = 1; i <= count; i++) {
						const playerSetupDiv = document.createElement('div');
						playerSetupDiv.classList.add('player-setup');

						const label = document.createElement('label');
						label.textContent = `Player ${i}:`;
						label.htmlFor = `player${i}-name`;

						const nameInput = document.createElement('input');
						nameInput.type = 'text';
						nameInput.id = `player${i}-name`;
						nameInput.placeholder = `Player ${i}`;
						nameInput.dataset.playerId = i;
						if (existingData[i - 1] && existingData[i - 1].name) {
							nameInput.value = existingData[i - 1].name;
						}

						const select = document.createElement('select');
						select.id = `player${i}-animal`;
						select.dataset.playerId = i;

						const previousAnimal = existingData[i - 1] ? existingData[i - 1].animal : '';

						const playerTypeSelect = document.createElement('select');
						playerTypeSelect.classList.add('player-type-select');
						playerTypeSelect.id = `player${i}-type`;
						playerTypeSelect.dataset.playerId = i;

						const humanOption = document.createElement('option');
						humanOption.value = 'human';
						humanOption.textContent = 'Human';
						playerTypeSelect.appendChild(humanOption);

						const computerOption = document.createElement('option');
						computerOption.value = 'computer';
						computerOption.textContent = 'Computer';
						playerTypeSelect.appendChild(computerOption);

						const previousPlayerType = existingData[i - 1] ? existingData[i - 1].playerType : 'human';
						playerTypeSelect.value = previousPlayerType;

						const updateAnimalSelectOptions = () => {
							const isHuman = playerTypeSelect.value === 'human';
							const currentValue = select.value || previousAnimal;
							select.innerHTML = '';

							const availableAnimals = isHuman
								? Object.keys(ANIMAL_ROSTER).filter((animal) => unlockedAnimals.has(animal))
								: Object.keys(ANIMAL_ROSTER);

							availableAnimals.forEach((animal) => {
								const option = document.createElement('option');
								option.value = animal;
								option.textContent = animal;
								select.appendChild(option);
							});

							if (availableAnimals.includes(currentValue)) {
								select.value = currentValue;
							} else if (availableAnimals.length > 0) {
								select.value = availableAnimals[0];
							}
						};

						playerTypeSelect.addEventListener('change', updateAnimalSelectOptions);
						updateAnimalSelectOptions();

						playerSetupDiv.appendChild(label);
						playerSetupDiv.appendChild(nameInput);
						playerSetupDiv.appendChild(select);
						playerSetupDiv.appendChild(playerTypeSelect);
						playerSelectionsContainer.appendChild(playerSetupDiv);
					}
				}

				function startGame() {
					const players = [];

					if (currentMode === 'challenger') {
						let playerHP = INITIAL_HP;
						if (selectedChallengerAnimal === 'Gorilla') {
							playerHP = 4;
						}
						players.push({
							id: 0,
							name: 'You',
							animal: selectedChallengerAnimal,
							hp: playerHP,
							maxHp: playerHP,
							isAlive: true,
							isComputer: false,
							status: {
								isShielded: false,
								isSleeping: false,
							},
							oneTimeActions: {
								hasHealed: false,
								hasShielded: false,
								hasUsedAbility: false,
							},
							abilityCooldown: 0,
							abilityDisabled: false,
						});

						let opponentHP = INITIAL_HP;
						if (selectedOpponentAnimal === 'Gorilla') {
							opponentHP = 4;
						}
						players.push({
							id: 1,
							name: 'Challenger',
							animal: selectedOpponentAnimal,
							hp: opponentHP,
							maxHp: opponentHP,
							isAlive: true,
							isComputer: true,
							status: {
								isShielded: false,
								isSleeping: false,
							},
							oneTimeActions: {
								hasHealed: false,
								hasShielded: false,
								hasUsedAbility: false,
							},
							abilityCooldown: 0,
							abilityDisabled: false,
						});
					} else {
						const setupDivs = playerSelectionsContainer.querySelectorAll('.player-setup');
						setupDivs.forEach((setupDiv, index) => {
							const nameInput = setupDiv.querySelector('input[type="text"]');
							const animalSelect = setupDiv.querySelector('select');
							const playerTypeSelect = setupDiv.querySelector('.player-type-select');
							const playerName = nameInput.value.trim() || `Player ${index + 1}`;
							const animalType = animalSelect.value;
							const playerType = playerTypeSelect.value;

							let initialHP = INITIAL_HP;
							if (animalType === 'Gorilla') {
								initialHP = 4;
							}

							players.push({
								id: index,
								name: playerName,
								animal: animalType,
								hp: initialHP,
								maxHp: initialHP,
								isAlive: true,
								isComputer: playerType === 'computer',
								status: {
									isShielded: false,
									isSleeping: false,
								},
								oneTimeActions: {
									hasHealed: false,
									hasShielded: false,
									hasUsedAbility: false,
								},
								abilityCooldown: 0,
								abilityDisabled: false,
							});
						});
					}

					const randomFirstPlayerIndex = Math.floor(Math.random() * players.length);

					state = {
						players,
						currentPlayerIndex: randomFirstPlayerIndex,
						gameState: 'playing',
						turn: 1,
						actionInProgress: null,
						turnSkipped: false,
						log: [],
					};

					stateHistory = [];

					logMessage('The battle for the Animal Kingdom begins!');
					players.forEach((player) => {
						logMessage(`${player.name} is the ${player.animal}`, 1);
					});
					logMessage(
						`${players[randomFirstPlayerIndex].name} (${players[randomFirstPlayerIndex].animal}) will go first!`,
						1,
					);

					setupScreen.style.display = 'none';
					gameScreen.style.display = 'flex';
					document.body.classList.add('game-active');

					startTurn();
				}

				// --- GAME FLOW & TURN MANAGEMENT ---
				function saveStateToHistory() {
					const stateCopy = JSON.parse(JSON.stringify(state));
					stateHistory.push(stateCopy);
				}

				function handleUndo() {
					if (stateHistory.length === 0) return;

					const previousState = stateHistory.pop();
					state = JSON.parse(JSON.stringify(previousState));

					logMessage('⏪ Turn undone.');

					render();
				}

				function startTurn() {
					saveStateToHistory();

					const currentPlayer = state.players[state.currentPlayerIndex];
					state.turnSkipped = false;

					logMessage(`It's ${currentPlayer.name}'s (${currentPlayer.animal}) turn!`);

					if (currentPlayer.status.isShielded) {
						currentPlayer.status.isShielded = false;
						logMessage(`${currentPlayer.name}'s (${currentPlayer.animal}) shield has worn off.`, 1);
					}

					if (currentPlayer.status.isSleeping) {
						currentPlayer.status.isSleeping = false;
						logMessage(
							`${currentPlayer.name} (${currentPlayer.animal}) is asleep and skips their turn!`,
							1,
						);
						state.actionInProgress = null;
						state.turnSkipped = true;
						render();
						setTimeout(endTurn, 1500);
						return;
					}

					render();

					if (currentPlayer.isComputer) {
						setTimeout(() => {
							playComputerTurn(currentPlayer);
						}, 1000);
					}
				}

				function playComputerTurn(player) {
					const aliveOpponents = state.players.filter((p) => p.isAlive && p.id !== player.id);
					if (aliveOpponents.length === 0) {
						endTurn();
						return;
					}

					const randomTarget = aliveOpponents[Math.floor(Math.random() * aliveOpponents.length)];
					handleAttack(player, randomTarget);
					setTimeout(() => {
						endTurn();
					}, 1000);
				}

				function showConfetti() {
					const confettiContainer = document.createElement('div');
					confettiContainer.id = 'confetti-container';
					confettiContainer.style.cssText = `
						position: fixed;
						top: 0;
						left: 0;
						width: 100%;
						height: 100%;
						pointer-events: none;
						z-index: 50;
					`;
					document.body.appendChild(confettiContainer);

					const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];
					const confettiCount = 100;

					for (let i = 0; i < confettiCount; i++) {
						const confetti = document.createElement('div');
						confetti.style.cssText = `
							position: absolute;
							width: 10px;
							height: 10px;
							background-color: ${colors[Math.floor(Math.random() * colors.length)]};
							top: -10px;
							left: ${Math.random() * 100}%;
							opacity: ${0.7 + Math.random() * 0.3};
							transform: rotate(${Math.random() * 360}deg);
						`;
						confettiContainer.appendChild(confetti);

						const duration = 2000 + Math.random() * 1000;
						const startTime = Date.now();
						const startLeft = parseFloat(confetti.style.left);
						const horizontalDrift = (Math.random() - 0.5) * 30;

						const animate = () => {
							const elapsed = Date.now() - startTime;
							const progress = elapsed / duration;

							if (progress < 1) {
								confetti.style.top = `${progress * 110}vh`;
								confetti.style.left = `${startLeft + horizontalDrift * progress}%`;
								confetti.style.transform = `rotate(${progress * 720}deg)`;
								requestAnimationFrame(animate);
							} else {
								confetti.remove();
							}
						};

						setTimeout(() => requestAnimationFrame(animate), Math.random() * 100);
					}

					setTimeout(() => {
						confettiContainer.remove();
					}, 3500);
				}

				function endTurn() {
					const lastPlayer = state.players[state.currentPlayerIndex];
					if (lastPlayer.abilityCooldown > 0) {
						lastPlayer.abilityCooldown--;
					}

					const alivePlayers = state.players.filter((p) => p.isAlive);
					if (alivePlayers.length <= 1) {
						state.gameState = 'gameEnding';
						render();
						showConfetti();
						setTimeout(() => endGame(alivePlayers[0]), 2000);
						return;
					}

					let nextIndex = (state.currentPlayerIndex + 1) % state.players.length;
					while (!state.players[nextIndex].isAlive) {
						nextIndex = (nextIndex + 1) % state.players.length;
					}
					state.currentPlayerIndex = nextIndex;
					state.turn++;

					startTurn();
				}

				function endGame(winner) {
					state.gameState = 'gameOver';
					playSound('victory');
					const announcement = winner
						? `${winner.name} the ${winner.animal} is the new ruler!`
						: "It's a draw!";
					logMessage(announcement);
					winnerAnnouncement.textContent = announcement;
					gameOverScreen.style.display = 'flex';
				}

				// --- RENDERING ---
				function render() {
					renderPlayers();
					renderControls();
					renderLog();
				}

				function renderPlayers() {
					playersContainer.innerHTML = '';
					state.players.forEach((player) => {
						const card = document.createElement('div');
						card.classList.add('player-card');
						card.dataset.playerId = player.id;
						if (!player.isAlive) card.classList.add('dead');
						if (player.id === state.currentPlayerIndex && player.isAlive) card.classList.add('active');

						// Check if card should be selectable
						if (state.actionInProgress) {
							const {type, sourceId, targets, requiredTargets} = state.actionInProgress;
							const isSelf = player.id === sourceId;
							const isAlreadyTargeted = targets.includes(player.id);

							let isSelectable = false;
							if (type === 'attack' || type === 'spitball' || type === 'rampage') {
								isSelectable = !isSelf && player.isAlive;
							} else if (type === 'strike') {
								isSelectable = !isSelf && player.isAlive && !isAlreadyTargeted;
							} else if (type === 'mischief') {
								isSelectable = !isSelf && player.isAlive;
							}

							if (isSelectable) {
								card.classList.add('selectable');
							}
						}

						const hpPercentage = Math.min((player.hp / player.maxHp) * 100, 100);
						let hpColor;
						if (player.hp > player.maxHp) {
							hpColor = '#3498DB';
						} else if (hpPercentage > 60) {
							hpColor = 'var(--hp-full)';
						} else if (hpPercentage > 30) {
							hpColor = 'var(--hp-medium)';
						} else {
							hpColor = 'var(--hp-low)';
						}

						let statusIconsHTML = '';
						if (player.status.isShielded)
							statusIconsHTML += `<div class="status-icon" title="Shielded">🛡️<span class="tooltip">Blocking next damage</span></div>`;
						if (player.status.isSleeping)
							statusIconsHTML += `<div class="status-icon" title="Sleeping">💤<span class="tooltip">Skipping next turn</span></div>`;
						if (player.oneTimeActions.hasHealed)
							statusIconsHTML += `<div class="status-icon" title="Heal Used">💚<span class="tooltip">Heal has been used</span></div>`;
						if (player.oneTimeActions.hasShielded)
							statusIconsHTML += `<div class="status-icon" title="Shield Used">🛡️<span class="tooltip">Shield has been used</span></div>`;
						if (player.abilityCooldown > 0)
							statusIconsHTML += `<div class="status-icon" title="Ability on Cooldown">⏳<span class="tooltip">Ability on cooldown (${player.abilityCooldown} turn/s)</span></div>`;
						if (player.abilityDisabled)
							statusIconsHTML += `<div class="status-icon" title="Ability Disabled">🚫<span class="tooltip">Ability permanently disabled</span></div>`;
						if (
							player.oneTimeActions.hasUsedAbility
							&& (player.animal === 'Gorilla' || player.animal === 'Monkey')
						)
							statusIconsHTML += `<div class="status-icon" title="Ability Used">✓<span class="tooltip">One-time ability has been used</span></div>`;

						card.innerHTML = `
                        <div class="player-info">
                            <span class="player-name">${player.animal}</span>
                            <span class="animal-name">${player.name}</span>
                        </div>
                        <div class="hp-bar-container">
                            <div class="hp-bar" style="width: ${hpPercentage}%; background-color: ${hpColor};"></div>
                        </div>
                        <div>HP: ${player.hp} / ${player.maxHp}</div>
                        <div class="status-icons">${statusIconsHTML}</div>
                    `;
						playersContainer.appendChild(card);
					});
				}

				function renderControls() {
					const currentPlayer = state.players[state.currentPlayerIndex];
					turnIndicator.textContent = state.actionInProgress
						? state.actionInProgress.prompt
						: `It's ${currentPlayer.name}'s (${currentPlayer.animal}) turn!`;

					const isGameEnding = state.gameState === 'gameEnding';

					const abilityButton = document.querySelector('[data-action="ability"]');
					const abilityNames = {
						Coyote: 'Howl',
						Llama: 'Spitball',
						Tiger: 'Strike',
						Gorilla: 'Rampage',
						Monkey: 'Mischief',
					};
					abilityButton.innerHTML = `<i data-lucide="sparkles"></i><span>Use A<u>b</u>ility: ${abilityNames[currentPlayer.animal]}</span>`;
					abilityButton.disabled = isGameEnding || currentPlayer.abilityCooldown > 0 || currentPlayer.abilityDisabled;
					lucide.createIcons();

					document.querySelector('[data-action="heal"]').disabled = isGameEnding || currentPlayer.oneTimeActions.hasHealed;
					document.querySelector('[data-action="shield"]').disabled = isGameEnding ||
						currentPlayer.oneTimeActions.hasShielded;
					document.querySelector('[data-action="attack"]').disabled = isGameEnding;
					document.querySelector('[data-action="nothing"]').disabled = isGameEnding;

					if (currentPlayer.animal === 'Tiger') {
						const livingOpponents = state.players.filter(
							(p) => p.isAlive && p.id !== currentPlayer.id,
						).length;
						if (livingOpponents < 2) {
							abilityButton.disabled = true;
						}
					}

					if (currentPlayer.animal === 'Gorilla' || currentPlayer.animal === 'Monkey') {
						if (currentPlayer.oneTimeActions.hasUsedAbility) {
							abilityButton.disabled = true;
						}
					}

					actionButtonsContainer.querySelectorAll('button').forEach((btn) => {
						if (state.actionInProgress) {
							btn.style.display = 'none';
						} else {
							btn.style.display = 'inline-flex';
						}
					});

					undoBtn.disabled = stateHistory.length === 0 || state.actionInProgress || currentPlayer.isComputer || isGameEnding;
				}

				function renderLog() {
					gameLog.innerHTML = state.log
						.map((entry, index) => {
							let prefix = '';
							if (entry.indent > 0) {
								const nextEntry = state.log[index + 1];
								const hasNextSibling = nextEntry && nextEntry.indent === entry.indent;
								const hasChildren = nextEntry && nextEntry.indent > entry.indent;

								if (entry.indent === 1) {
									if (hasChildren) {
										prefix = hasNextSibling ? '├─┐ ' : '└─┐ ';
									} else {
										prefix = hasNextSibling ? '├── ' : '└── ';
									}
								} else if (entry.indent === 2) {
									const connector = hasNextSibling ? '├─┐ ' : '└─┐ ';
									if (hasChildren) {
										prefix = '  ' + connector;
									} else {
										prefix = '  ' + (hasNextSibling ? '├── ' : '└── ');
									}
								} else if (entry.indent === 3) {
									const connector = hasNextSibling ? '├── ' : '└── ';
									prefix = '    ' + connector;
								}
							}
							return `<div class="log-entry">${prefix}${entry.message}</div>`;
						})
						.join('');
					gameLog.scrollTop = gameLog.scrollHeight;
				}

				function logMessage(message, indent = 0) {
					state.log.push({message, indent});
				}

				// --- ACTION HANDLING ---
				actionButtonsContainer.addEventListener('click', (e) => {
					const button = e.target.closest('.action-btn');
					if (!button || button.disabled) return;
					const currentPlayer = state.players[state.currentPlayerIndex];
					if (
						state.gameState !== 'playing'
						|| state.actionInProgress
						|| state.turnSkipped
						|| currentPlayer.isComputer
					)
						return;

					const action = button.dataset.action;
					const source = currentPlayer;

					switch (action) {
						case 'attack':
							initiateTargetSelection('attack', source.id, 1, `Select a target to attack.`);
							break;
						case 'ability':
							handleAbility(source);
							break;
						case 'heal':
							handleHeal(source);
							break;
						case 'shield':
							handleShield(source);
							break;
						case 'nothing':
							playSound('nothing');
							logMessage(`${source.name} (${source.animal}) did nothing.`, 1);
							endTurn();
							break;
					}
				});

				playersContainer.addEventListener('click', (e) => {
					const currentPlayer = state.players[state.currentPlayerIndex];
					if (!state.actionInProgress || state.turnSkipped || currentPlayer.isComputer) return;
					const card = e.target.closest('.player-card.selectable');
					if (!card) return;

					const targetId = parseInt(card.dataset.playerId, 10);
					const {targets} = state.actionInProgress;

					if (!targets.includes(targetId)) {
						targets.push(targetId);
					}

					const {type, sourceId, requiredTargets} = state.actionInProgress;
					if (targets.length === requiredTargets) {
						const source = state.players[sourceId];
						const targetPlayers = targets.map((id) => state.players[id]);

						if (type === 'attack') handleAttack(source, targetPlayers[0]);
						if (type === 'spitball') handleSpitball(source, targetPlayers[0]);
						if (type === 'strike') handleStrike(source, targetPlayers[0], targetPlayers[1]);
						if (type === 'rampage') handleRampage(source, targetPlayers[0]);
						if (type === 'mischief') handleMischief(source, targetPlayers[0]);

						state.actionInProgress = null;
						endTurn();
					} else {
						state.actionInProgress.prompt = `Select target 2 of ${requiredTargets}.`;
						render();
					}
				});

				function initiateTargetSelection(type, sourceId, requiredTargets, prompt) {
					state.actionInProgress = {
						type,
						sourceId,
						requiredTargets,
						targets: [],
						prompt,
					};
					render();
				}

				function applyDamage(target, damage, source) {
					if (target.status.isShielded) {
						playSound('shield');
						logMessage(
							`${target.name}'s (${target.animal}) shield blocked the attack from ${source.name}!`,
							2,
						);
						return 0;
					}

					playSound('damage');
					const actualDamage = Math.min(target.hp, damage);
					target.hp -= actualDamage;
					logMessage(`${target.name} (${target.animal}) now has ${target.hp}/${target.maxHp} HP.`, 2);
					if (target.hp <= 0) {
						target.isAlive = false;
						playSound('defeat');
						logMessage(`${target.name}'s (${target.animal}) has been defeated!`, 3);
						unlockAnimal(target.animal);
					}
					return actualDamage;
				}

				function handleAttack(source, target) {
					playSound('attack');
					logMessage(`${source.name} (${source.animal}) attacks ${target.name} (${target.animal}).`, 1);
					applyDamage(target, 1, source);
				}

				function handleHeal(source) {
					playSound('heal');
					source.oneTimeActions.hasHealed = true;
					if (source.hp >= source.maxHp) {
						source.hp += 1;
						logMessage(
							`${source.name} (${source.animal}) is overhealed for 1 HP! (${source.hp}/${source.maxHp})`,
							1,
						);
					} else {
						const amountToHeal = Math.min(1, source.maxHp - source.hp);
						source.hp += amountToHeal;
						logMessage(`${source.name} (${source.animal}) healed for ${amountToHeal} HP.`, 1);
					}
					endTurn();
				}

				function handleShield(source) {
					playSound('shield');
					source.oneTimeActions.hasShielded = true;
					source.status.isShielded = true;
					logMessage(
						`${source.name} (${source.animal}) raised a shield! It will block the next incoming damage.`,
						1,
					);
					endTurn();
				}

				// --- ABILITY LOGIC ---
				function handleAbility(source) {
					switch (source.animal) {
						case 'Coyote':
							handleHowl(source);
							render();
							break;
						case 'Llama':
							initiateTargetSelection('spitball', source.id, 1, `Select a target for Spitball.`);
							break;
						case 'Tiger':
							initiateTargetSelection('strike', source.id, 2, `Select target 1 of 2 for Strike.`);
							break;
						case 'Gorilla':
							initiateTargetSelection('rampage', source.id, 1, `Select a target for Rampage.`);
							break;
						case 'Monkey':
							initiateTargetSelection('mischief', source.id, 1, `Select a target for Mischief.`);
							break;
					}
				}

				function handleHowl(source) {
					playSound('howl');
					source.abilityCooldown = 2;
					logMessage(`${source.name} the Coyote lets out a piercing Howl!`, 1);
					state.players.forEach((p) => {
						if (p.isAlive && p.id !== source.id && p.animal !== 'Coyote') {
							p.status.isSleeping = true;
							playSound('sleep');
						}
					});
				}

				function handleSpitball(source, target) {
					playSound('spitball');
					const rand = Math.random();
					let damage = 0;
					if (rand < 0.15) {
						damage = 2;
					} else if (rand < 0.55) {
						damage = 1;
					}

					logMessage(`${source.name} the Llama uses Spitball on ${target.name} (${target.animal})...`, 1);
					if (damage > 0) {
						logMessage(`It's a direct hit for ${damage} damage!`, 2);
						applyDamage(target, damage, source);
					} else {
						logMessage(`It missed! 0 damage.`, 2);
					}
				}

				function handleStrike(source, target1, target2) {
					playSound('strike');
					logMessage(`${source.name} the Tiger uses Strike on ${target1.name} and ${target2.name}!`, 1);
					applyDamage(target1, 1, source);
					applyDamage(target2, 1, source);
				}

				function handleRampage(source, target) {
					playSound('rampage');
					source.oneTimeActions.hasUsedAbility = true;
					logMessage(
						`${source.name} the Gorilla unleashes a devastating Rampage on ${target.name} (${target.animal})!`,
						1,
					);
					applyDamage(target, 4, source);
				}

				function handleMischief(source, target) {
					playSound('mischief');
					source.oneTimeActions.hasUsedAbility = true;
					target.abilityDisabled = true;
					logMessage(`${source.name} the Monkey uses Mischief on ${target.name} (${target.animal})!`, 1);
					logMessage(`${target.name}'s (${target.animal}) ability has been permanently disabled!`, 2);
				}

				// --- INITIALIZE ---
				initializeSetup();
				lucide.createIcons();
			});
		</script>
	</body>
</html>
